<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Par_interp__Program (par_interp@26bb1931b3ad.Par_interp__Program)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">par_interp@26bb1931b3ad</a> &#x00BB; Par_interp__Program</nav><h1>Module <code>Par_interp__Program</code></h1><p>Implementation of the functions acting on <span class="xref-unresolved" title="unresolved reference to &quot;Ast_ann.program_ann&quot;"><code>Ast_ann</code>.program_ann</span>.</p></header><dl><dt class="spec exception" id="exception-No_previous_statements"><a href="#exception-No_previous_statements" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">No_previous_statements</span></code></dt><dt class="spec exception" id="exception-No_next_statements"><a href="#exception-No_next_statements" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">No_next_statements</span></code></dt><dt class="spec exception" id="exception-Statement_without_stack"><a href="#exception-Statement_without_stack" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Statement_without_stack</span> <span class="keyword">of</span> string</code></dt><dt class="spec exception" id="exception-Statement_empty_stack"><a href="#exception-Statement_empty_stack" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Statement_empty_stack</span> <span class="keyword">of</span> string</code></dt><dt class="spec exception" id="exception-Root_thread_par_update"><a href="#exception-Root_thread_par_update" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Root_thread_par_update</span></code></dt><dt class="spec exception" id="exception-Prev_stmt_not_Par"><a href="#exception-Prev_stmt_not_Par" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Prev_stmt_not_Par</span></code></dt></dl><dl><dt class="spec type" id="type-child_branch"><a href="#type-child_branch" class="anchor"></a><code><span class="keyword">type</span> child_branch</code><code> = </code><table class="variant"><tr id="type-child_branch.Left" class="anchored"><td class="def constructor"><a href="#type-child_branch.Left" class="anchor"></a><code>| </code><code><span class="constructor">Left</span></code></td></tr><tr id="type-child_branch.Right" class="anchored"><td class="def constructor"><a href="#type-child_branch.Right" class="anchor"></a><code>| </code><code><span class="constructor">Right</span></code></td></tr><tr id="type-child_branch.Root" class="anchored"><td class="def constructor"><a href="#type-child_branch.Root" class="anchor"></a><code>| </code><code><span class="constructor">Root</span></code></td></tr></table></dt><dd><p>type used to discern whether the thread contains a program contained in the first (Left) or in the second (Right) element of the <code>Par</code> statement of the parent thread that created it.</p></dd></dl><dl><dt class="spec value" id="val-max_num_chld_threads"><a href="#val-max_num_chld_threads" class="anchor"></a><code><span class="keyword">val</span> max_num_chld_threads : int</code></dt><dd><p>Each thread can have max 2 running child threads at a time, since a <code>Par</code> statement creates two child threads and the parent thread waits for both children to complete before proceeding its execution.</p></dd></dl><dl><dt class="spec value" id="val-prepend_stmt"><a href="#val-prepend_stmt" class="anchor"></a><code><span class="keyword">val</span> prepend_stmt : <span>stmt_ann:<a href="../Par_interp/Ast_ann/index.html#type-stmt_ann">Par_interp.Ast_ann.stmt_ann</a></span> <span>&#45;&gt;</span> <a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a> <span>&#45;&gt;</span> <a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a></code></dt><dd><p>Given a program, adds <code>stmt_ann</code> as the program's first statement/instruction.</p></dd></dl><dl><dt class="spec value" id="val-append_stmt"><a href="#val-append_stmt" class="anchor"></a><code><span class="keyword">val</span> append_stmt : <span>stmt_ann:<a href="../Par_interp/Ast_ann/index.html#type-stmt_ann">Par_interp.Ast_ann.stmt_ann</a></span> <span>&#45;&gt;</span> <a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a> <span>&#45;&gt;</span> <a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a></code></dt><dd><p>Given a program, adds <code>stmt_ann</code> as the program's last statement/instruction.</p></dd></dl><dl><dt class="spec value" id="val-prev_stmt"><a href="#val-prev_stmt" class="anchor"></a><code><span class="keyword">val</span> prev_stmt : <a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a> <span>&#45;&gt;</span> <a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a></code></dt><dd><p>Given a program <code>prg</code>, returns:</p><ul><li>A new program where <code>prg</code>'s previous statement becomes the current statement, or</li><li><code>prg</code>, if <code>prg</code>'s current statement is the first one (there are no previous statements.)</li></ul></dd></dl><dl><dt class="spec value" id="val-next_stmt"><a href="#val-next_stmt" class="anchor"></a><code><span class="keyword">val</span> next_stmt : <a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a> <span>&#45;&gt;</span> <a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a></code></dt><dd><p>Given a program <code>prg</code>, returns:</p><ul><li>A new program where <code>prg</code>'s next statement becomes the current statement, or</li><li><code>prg</code>, if <code>prg</code>'s current statement is the last one (there are no next statements.)</li></ul></dd></dl><dl><dt class="spec value" id="val-last_stmt"><a href="#val-last_stmt" class="anchor"></a><code><span class="keyword">val</span> last_stmt : <a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a> <span>&#45;&gt;</span> <a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a></code></dt><dd><p>Given a program <code>prg</code>, returns a new program where <code>prg</code>'s last statement becomes the current statement.</p></dd></dl><dl><dt class="spec value" id="val-get_prev_stmt"><a href="#val-get_prev_stmt" class="anchor"></a><code><span class="keyword">val</span> get_prev_stmt : <a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a> <span>&#45;&gt;</span> <a href="../Par_interp/Ast_ann/index.html#type-stmt_ann">Par_interp.Ast_ann.stmt_ann</a></code></dt><dd><p>Returns the statement preceding the current statement inside the program.</p><dl><dt>raises No_previous_statements</dt><dd><p>if the previous statements' list is empty (e.g. the given program's current statement is the first one.)</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-get_curr_stmt"><a href="#val-get_curr_stmt" class="anchor"></a><code><span class="keyword">val</span> get_curr_stmt : <a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a> <span>&#45;&gt;</span> <a href="../Par_interp/Ast_ann/index.html#type-stmt_ann">Par_interp.Ast_ann.stmt_ann</a></code></dt><dd><p>Returns the current statement inside the program.</p></dd></dl><dl><dt class="spec value" id="val-push_stmt_counter"><a href="#val-push_stmt_counter" class="anchor"></a><code><span class="keyword">val</span> push_stmt_counter : int <span>&#45;&gt;</span> <a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a> <span>&#45;&gt;</span> <a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a></code></dt><dd><p>Given an int value <code>stmt_counter</code> representing the current statement counter and a program <code>prg</code>, pushes <code>stmt_counter</code> onto the source code stack associated to <code>prg</code>'s current statement.</p><dl><dt>raises Statement_without_stack</dt><dd><p>if the current statement doesn't have an associated source code stack.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-top_prev_stmt_counter"><a href="#val-top_prev_stmt_counter" class="anchor"></a><code><span class="keyword">val</span> top_prev_stmt_counter : <a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Given a program <code>prg</code>, returns the statement counter value located on the top of the source code stack associated to <code>prg</code>'s previous statement.</p><dl><dt>raises Statement_without_stack</dt><dd><p>if the current statement doesn't have an associated source code stack.</p></dd></dl><dl><dt>raises Statement_empty_stack</dt><dd><p>if the previous statement's source code stack is empty.</p></dd></dl><dl><dt>raises No_previous_statements</dt><dd><p>if there are no statements preceding the current statement.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-pop_prev_stmt_counter"><a href="#val-pop_prev_stmt_counter" class="anchor"></a><code><span class="keyword">val</span> pop_prev_stmt_counter : <a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a> <span>&#45;&gt;</span> <a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a></code></dt><dd><p>Given a program <code>prg</code>, pops (removes) the statement counter value from the top of the source code stack associated to <code>prg</code>'s previous statement.</p><dl><dt>raises Statement_without_stack</dt><dd><p>if the current statement doesn't have an associated source code stack.</p></dd></dl><dl><dt>raises Statement_empty_stack</dt><dd><p>if the previous statement's source code stack is empty.</p></dd></dl><dl><dt>raises No_previous_statements</dt><dd><p>if there are no statements preceding the current statement.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-is_par_prg_at_end"><a href="#val-is_par_prg_at_end" class="anchor"></a><code><span class="keyword">val</span> is_par_prg_at_end : <a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Given a program, returns <code>true</code> if the current statement is <code>Par_prg_end</code>, <code>false</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-inc_prev_par_finished_children"><a href="#val-inc_prev_par_finished_children" class="anchor"></a><code><span class="keyword">val</span> inc_prev_par_finished_children : <a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a> <span>&#45;&gt;</span> <a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a></code></dt><dd><p>Given a program having <code>Par</code> as the previous statement, increases <code>num_chld_done</code> field contained in the aforementioned <code>Par</code> statement by 1. Called whenever a new child thread associated to said <code>Par</code> statement is created.</p></dd></dl><dl><dt class="spec value" id="val-dec_prev_par_finished_children"><a href="#val-dec_prev_par_finished_children" class="anchor"></a><code><span class="keyword">val</span> dec_prev_par_finished_children : <a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a> <span>&#45;&gt;</span> <a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a></code></dt><dd><p>Given a program having <code>Par</code> as the previous statement, increases <code>num_chld_done</code> field contained in the aforementioned <code>Par</code> statement by 1. Called whenever a child thread associated to said <code>Par</code> statement terminates.</p><dl><dt>raises Prev_stmt_not_Par</dt><dd><p>if the previous statement in the given program parameter is not <code>Par</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-update_par_prg"><a href="#val-update_par_prg" class="anchor"></a><code><span class="keyword">val</span> update_par_prg : <span>chld_branch:<a href="index.html#type-child_branch">child_branch</a></span> <span>&#45;&gt;</span> <span>chld_prg:<a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a></span> <span>&#45;&gt;</span> <span>parent_prg:<a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a></span> <span>&#45;&gt;</span> <a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a></code></dt><dd><p>Given a thread branch, a child program and a parent program whose previous statement is a <code>Par</code> statement, puts the updated child program into the parent's <code>Par</code> statement.</p><dl><dt>parameter chld_branch</dt><dd><p>The child thread's branch (<code>Left</code> or <code>Right</code>), to determine whether the program contained in the child thread belongs to the first or the second program inside the <span class="xref-unresolved" title="unresolved reference to &quot;Program_ann.Par&quot;"><code>Program_ann</code>.Par</span> statement of the parent thread. If it's <code>Root</code>, then an exception is raised.</p></dd></dl><dl><dt>parameter chld_prg</dt><dd><p>The updated child program to put into the parent program's <code>Par</code> statement.</p></dd></dl><dl><dt>parameter t_parent</dt><dd><p>The parent program whose previous statement is the <code>Par</code> statement to update with the finished child thread's program.</p></dd></dl><dl><dt>returns</dt><dd><p>The updated parent program.</p></dd></dl><dl><dt>raises Root_thread_par_update</dt><dd><p>if <code>chld_branch</code> is <code>Root</code>.</p></dd></dl><dl><dt>raises Prev_stmt_not_Par</dt><dd><p>if the parent program's previous statement is not <code>Par</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-update_par_prg_fwd"><a href="#val-update_par_prg_fwd" class="anchor"></a><code><span class="keyword">val</span> update_par_prg_fwd : <span>chld_branch:<a href="index.html#type-child_branch">child_branch</a></span> <span>&#45;&gt;</span> <span>chld_prg:<a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a></span> <span>&#45;&gt;</span> <span>parent_prg:<a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a></span> <span>&#45;&gt;</span> <a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a></code></dt><dd><p>Handles the forward execution of statement <span class="xref-unresolved" title="unresolved reference to &quot;Program_ann.Par_prg_end&quot;"><code>Program_ann</code>.Par_prg_end</span> (that is, a child thread terminated its program execution) by calling <a href="index.html#val-update_par_prg"><code>update_par_prg</code></a> and incrementing <code>Par</code>'s field <code>num_chld_done</code> by 1.</p></dd></dl><dl><dt class="spec value" id="val-is_children_execution_done"><a href="#val-is_children_execution_done" class="anchor"></a><code><span class="keyword">val</span> is_children_execution_done : <a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Given a waiting thread's program, returns a boolean value indicating whether its children are done with their execution (<code>true</code>) or not (<code>false</code>).</p><dl><dt>raises Prev_stmt_not_Par</dt><dd><p>if the parent program's previous statement is not <code>Par</code> (and therefore we're most likely not dealing with a waiting thread).</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-is_prev_stmt_par"><a href="#val-is_prev_stmt_par" class="anchor"></a><code><span class="keyword">val</span> is_prev_stmt_par : <a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Given a waiting thread's program, returns a boolean value indicating whether its previous statement is <code>Par</code> (<code>true</code>) or not (<code>false</code>).</p></dd></dl><dl><dt class="spec value" id="val-get_last_executed_par_prg"><a href="#val-get_last_executed_par_prg" class="anchor"></a><code><span class="keyword">val</span> get_last_executed_par_prg : int <span>&#45;&gt;</span> <a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a> <span>&#45;&gt;</span> <span><span>(<a href="../Par_interp/Ast_ann/index.html#type-program_ann">Par_interp.Ast_ann.program_ann</a> * <a href="index.html#type-child_branch">child_branch</a>)</span> option</span></code></dt><dd><p>Given an int value representing the last statement's execution counter and a program whose previous statement is <code>Par</code>, returns a pair <code>Some (prg, branch)</code> if the <code>Par statement</code> contains the last executed statement in one of its two programs (indicated by <code>branch</code>), <code>None</code> otherwise.</p><dl><dt>raises Prev_stmt_not_Par</dt><dd><p>if the given program's previous statement is not <code>Par</code>.</p></dd></dl></dd></dl></div></body></html>