<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Delta (par_interp@26bb1931b3ad.Par_interp.Delta)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">par_interp@26bb1931b3ad</a> &#x00BB; <a href="../index.html">Par_interp</a> &#x00BB; Delta</nav><h1>Module <code>Par_interp.Delta</code></h1></header><aside><p>Implementation of the auxiliary store and the functions acting on it.</p></aside><dl><dt class="spec exception" id="exception-Delta_stack_error"><a href="#exception-Delta_stack_error" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Delta_stack_error</span> <span class="keyword">of</span> string</code></dt></dl><dl><dt class="spec value" id="val-exc_ide_stack_not_found"><a href="#val-exc_ide_stack_not_found" class="anchor"></a><code><span class="keyword">val</span> exc_ide_stack_not_found : string <span>&#45;&gt;</span> exn</code></dt></dl><dl><dt class="spec type" id="type-ide_stacks"><a href="#type-ide_stacks" class="anchor"></a><code><span class="keyword">type</span> ide_stacks</code><code> = </code><table class="variant"><tr id="type-ide_stacks.Ide_stacks" class="anchored"><td class="def constructor"><a href="#type-ide_stacks.Ide_stacks" class="anchor"></a><code>| </code><code><span class="constructor">Ide_stacks</span> <span class="keyword">of</span> <span><span>(<a href="../Ast/index.html#type-ide">Ast.ide</a> * <span>int list</span>)</span> list</span></code></td></tr></table></dt><dd><p><code>ide_stacks</code> is a type representing a list of tuples <code>(var_name, prev_values_stack)</code>; its goal is to keep track of variables' previous values each time a destructive assignment is performed, by pushing the older value onto the respective variable's stack before performing the assignment. By doing so, previous values of any given variable can be retrieved during reverse execution by simply &quot;popping&quot; the value in the head of the list and assigning it to that variable in the sigma store.</p></dd></dl><dl><dt class="spec value" id="val-private_push_ide"><a href="#val-private_push_ide" class="anchor"></a><code><span class="keyword">val</span> private_push_ide : <span>ide_stk:<a href="index.html#type-ide_stacks">ide_stacks</a></span> <span>&#45;&gt;</span> <span>ide_name:<a href="../Ast/index.html#type-ide">Ast.ide</a></span> <span>&#45;&gt;</span> <span>value:int</span> <span>&#45;&gt;</span> <a href="index.html#type-ide_stacks">ide_stacks</a></code></dt><dd><p>Pushes a value onto the specified <code>ide_name</code> variable's stack.</p><p>If a tuple (<code>ide_name</code>, <code>ide_stack_list</code>) already exists in <code>ide_stk</code>, <code>value</code> is simply prepended to that list (pushed onto that <code>ide_stack_list</code>): (<code>ide_name</code>, <code>value</code> :: <code>ide_stack_list</code>).</p><p>If a tuple for <code>ide_name</code> doesn't exist, a tuple (<code>ide_name</code>, <code>value</code> :: <code></code>) gets created and appended to <code>ide_stk</code>.</p><dl><dt>parameter ide_stk</dt><dd><p>The list of tuples (variable_name, variable_name_stack_list) representing variables' auxiliary store.</p></dd></dl><dl><dt>parameter ide_name</dt><dd><p>The name of the variable which underwent a destructive assignment, for which we want to preserve its previous value by pushing it onto its associated stack.</p></dd></dl><dl><dt>parameter value</dt><dd><p>The previous integer value to push onto the stack associated to <code>ide_name</code>.</p></dd></dl><dl><dt>returns</dt><dd><p>The updated <code>ide_stk</code>, where <code>value</code> has been pushed onto <code>ide_name</code>'s associated stack.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-private_top_ide"><a href="#val-private_top_ide" class="anchor"></a><code><span class="keyword">val</span> private_top_ide : <span>ide_stk:<a href="index.html#type-ide_stacks">ide_stacks</a></span> <span>&#45;&gt;</span> <span>ide_name:<a href="../Ast/index.html#type-ide">Ast.ide</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p>Retrieves the integer value from the top of the specified <code>ide_name</code> variable's stack.</p><dl><dt>parameter ide_stk</dt><dd><p>The list of tuples (variable_name, variable_name_stack_list).</p></dd></dl><dl><dt>parameter ide_name</dt><dd><p>The name of the variable associated to the stack from which we want to retrieve the integer value on its top.</p></dd></dl><dl><dt>returns</dt><dd><p>The integer on the top of the stack associated to <code>ide_name</code>.</p></dd></dl><dl><dt>raises Delta_stack_error</dt><dd><p>with a descriptive message about the variable/identifier, in case the tuple (<code>ide_name</code>, ide_name_stack_list) wasn't found inside <code>ide_stk</code>.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-private_pop_ide"><a href="#val-private_pop_ide" class="anchor"></a><code><span class="keyword">val</span> private_pop_ide : <span>ide_stk:<a href="index.html#type-ide_stacks">ide_stacks</a></span> <span>&#45;&gt;</span> <span>ide_name:<a href="../Ast/index.html#type-ide">Ast.ide</a></span> <span>&#45;&gt;</span> <a href="index.html#type-ide_stacks">ide_stacks</a></code></dt><dd><p>Pops (removes) the integer value from the top of the specified <code>ide_name</code> variable's stack.</p><dl><dt>parameter ide_stk</dt><dd><p>The list of tuples (variable_name, variable_name_stack_list).</p></dd></dl><dl><dt>parameter ide_name</dt><dd><p>The name of the variable associated to the stack from which we want to retrieve the integer value on its top.</p></dd></dl><dl><dt>returns</dt><dd><p>The updated <code>ide_stk</code>, where the element previously located on top of <code>ide_name</code>'s associated stack has been removed.</p><p>If <code>ide_name</code>'s associated stack contained a single element, the whole (<code>ide_name</code>, ide_name_stack_list) pair gets removed from <code>ide_stk</code>.</p></dd></dl><dl><dt>raises Delta_stack_error</dt><dd><p>with a descriptive message about the variable/identifier, in case the tuple (<code>ide_name</code>, ide_name_stack_list) wasn't found inside <code>ide_stk</code>.</p></dd></dl></dd></dl><dl><dt class="spec type" id="type-delta"><a href="#type-delta" class="anchor"></a><code><span class="keyword">type</span> delta</code><code> = </code><table class="variant"><tr id="type-delta.Delta" class="anchored"><td class="def constructor"><a href="#type-delta.Delta" class="anchor"></a><code>| </code><code><span class="constructor">Delta</span> <span class="keyword">of</span> <a href="index.html#type-ide_stacks">ide_stacks</a></code></td></tr></table></dt><dd><p><code>delta</code> is a type representing the auxiliary store, consisting of:</p><ol><li>A list of stacks <code>ide_stacks</code>, where each stack is contained inside a pair (&lt;identifier&gt;, &lt;integer list&gt;) that keeps track of each variable's value: every time a destructive assignment is performed on a certain &lt;ide&gt; variable, its previous value is pushed onto the stack associated to that &lt;ide&gt; variable, in order to preserve it.</li></ol><p>Unlike the serial version, <code>if_stack</code> and <code>while_stack</code> aren't present, since the parallel version doesn't implement neither <code>Ifthenelse</code> conditional execution nor <code>While</code> iterations (yet).</p></dd></dl><dl><dt class="spec value" id="val-push_ide"><a href="#val-push_ide" class="anchor"></a><code><span class="keyword">val</span> push_ide : <span>d:<a href="index.html#type-delta">delta</a></span> <span>&#45;&gt;</span> <span>ide_name:<a href="../Ast/index.html#type-ide">Ast.ide</a></span> <span>&#45;&gt;</span> <span>value:int</span> <span>&#45;&gt;</span> <a href="index.html#type-delta">delta</a></code></dt><dd><p>This is a wrapper which applies <a href="index.html#val-private_push_ide"><code>private_push_ide</code></a> to the parameter <code>ide_stks</code> inside the specified <code>d</code> delta parameter.</p></dd></dl><dl><dt class="spec value" id="val-top_ide"><a href="#val-top_ide" class="anchor"></a><code><span class="keyword">val</span> top_ide : <span>d:<a href="index.html#type-delta">delta</a></span> <span>&#45;&gt;</span> <span>ide_name:<a href="../Ast/index.html#type-ide">Ast.ide</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p>This is a wrapper which applies <a href="index.html#val-private_top_ide"><code>private_top_ide</code></a> to the parameter <code>ide_stks</code> inside the specified <code>d</code> delta parameter.</p></dd></dl><dl><dt class="spec value" id="val-pop_ide"><a href="#val-pop_ide" class="anchor"></a><code><span class="keyword">val</span> pop_ide : <span>d:<a href="index.html#type-delta">delta</a></span> <span>&#45;&gt;</span> <span>ide_name:<a href="../Ast/index.html#type-ide">Ast.ide</a></span> <span>&#45;&gt;</span> <a href="index.html#type-delta">delta</a></code></dt><dd><p>This is a wrapper which applies <a href="index.html#val-private_pop_ide"><code>private_pop_ide</code></a> to the parameter <code>ide_stks</code> inside the specified <code>d</code> delta parameter.</p></dd></dl><dl><dt class="spec value" id="val-empty_delta"><a href="#val-empty_delta" class="anchor"></a><code><span class="keyword">val</span> empty_delta : <a href="index.html#type-delta">delta</a></code></dt><dd><p>Returns an empty auxiliary store,</p></dd></dl></div></body></html>