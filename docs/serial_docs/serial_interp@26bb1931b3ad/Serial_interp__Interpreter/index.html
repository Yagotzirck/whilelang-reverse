<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Serial_interp__Interpreter (serial_interp@26bb1931b3ad.Serial_interp__Interpreter)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">serial_interp@26bb1931b3ad</a> &#x00BB; Serial_interp__Interpreter</nav><h1>Module <code>Serial_interp__Interpreter</code></h1><p>Augmented interpreter for the serial version of the while language.</p></header><dl><dt class="spec exception" id="exception-Assignment_to_non_var"><a href="#exception-Assignment_to_non_var" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Assignment_to_non_var</span> <span class="keyword">of</span> string</code></dt><dt class="spec exception" id="exception-Illegal_statement_fwd_execution"><a href="#exception-Illegal_statement_fwd_execution" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Illegal_statement_fwd_execution</span> <span class="keyword">of</span> string</code></dt><dt class="spec exception" id="exception-Illegal_statement_rev_execution"><a href="#exception-Illegal_statement_rev_execution" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Illegal_statement_rev_execution</span> <span class="keyword">of</span> string</code></dt></dl><dl><dt class="spec value" id="val-sem_int"><a href="#val-sem_int" class="anchor"></a><code><span class="keyword">val</span> sem_int : <span>expr:<a href="../Serial_interp/Ast/index.html#type-int_expr">Serial_interp.Ast.int_expr</a></span> <span>&#45;&gt;</span> <span>s:<a href="../Serial_interp/Sigma/index.html#type-sigma">Serial_interp.Sigma.sigma</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p>Integer semantics' definition.</p><dl><dt>parameter expr</dt><dd><p>The integer expression to evaluate.</p></dd></dl><dl><dt>parameter s</dt><dd><p>The sigma store (used in case the expression contains variables whose value must be retrieved.)</p></dd></dl><dl><dt>returns</dt><dd><p>The integer value resulting from the expression's evaluation.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-sem_bool"><a href="#val-sem_bool" class="anchor"></a><code><span class="keyword">val</span> sem_bool : <span>expr:<a href="../Serial_interp/Ast/index.html#type-bool_expr">Serial_interp.Ast.bool_expr</a></span> <span>&#45;&gt;</span> <span>expr:<a href="../Serial_interp/Sigma/index.html#type-sigma">Serial_interp.Sigma.sigma</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Boolean semantics' definition.</p><dl><dt>parameter expr</dt><dd><p>The boolean expression to evaluate.</p></dd></dl><dl><dt>parameter s</dt><dd><p>The sigma store (used in case the expression contains variables whose value must be retrieved.)</p></dd></dl><dl><dt>returns</dt><dd><p>The boolean value resulting from the expression's evaluation.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-assign_var_fwd"><a href="#val-assign_var_fwd" class="anchor"></a><code><span class="keyword">val</span> assign_var_fwd : <span>e1:<a href="../Serial_interp/Ast/index.html#type-int_expr">Serial_interp.Ast.int_expr</a></span> <span>&#45;&gt;</span> <span>e2:<a href="../Serial_interp/Ast/index.html#type-int_expr">Serial_interp.Ast.int_expr</a></span> <span>&#45;&gt;</span> <span>state:<a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a></span> <span>&#45;&gt;</span> <a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a></code></dt><dd><p>Performs forward execution's destructive assignment:</p><ol><li>Evaluates <code>e1</code>, making sure it's a variable;</li><li>Evaluates <code>e2</code>;</li><li>Assigns <code>e2</code>'s evaluation to the variable specified by <code>e1</code>, and returns the state with the above changes applied (see <span class="xref-unresolved" title="unresolved reference to &quot;State.dassign_fwd&quot;"><code>State</code>.dassign_fwd</span> for details such as pushing the previous value in the delta store before performing the assignment.)</li></ol><dl><dt>parameter e1</dt><dd><p>The expression containing the variable to which we must assign the new value.</p></dd></dl><dl><dt>parameter e2</dt><dd><p>The expression containing the value to assign.</p></dd></dl><dl><dt>parameter state</dt><dd><p>The state where the assignment must be performed.</p></dd></dl><dl><dt>returns</dt><dd><p>The new state where the assignment has been performed.</p></dd></dl><dl><dt>raises Assignment_to_non_var</dt><dd><p>if <code>e1</code>'s evaluation isn't a variable/identifier.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-assign_var_rev"><a href="#val-assign_var_rev" class="anchor"></a><code><span class="keyword">val</span> assign_var_rev : <span>e1:<a href="../Serial_interp/Ast/index.html#type-int_expr">Serial_interp.Ast.int_expr</a></span> <span>&#45;&gt;</span> <span>state:<a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a></span> <span>&#45;&gt;</span> <a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a></code></dt><dd><p>Performs reverse execution's destructive assignment:</p><ol><li>Evaluates <code>e1</code>, making sure it's a variable <code>ide</code>;</li><li>Assigns <code>ide</code>'s previous value to <code>ide</code> and returns the state with the above changes applied (see <span class="xref-unresolved" title="unresolved reference to &quot;State.dassign_rev&quot;"><code>State</code>.dassign_rev</span> for details such as popping <code>ide</code>'s previous value from the delta store.)</li></ol><dl><dt>parameter e1</dt><dd><p>The expression containing the variable to which we must assign the previous value.</p></dd></dl><dl><dt>parameter state</dt><dd><p>The state where the assignment must be performed.</p></dd></dl><dl><dt>returns</dt><dd><p>The new state where the assignment has been performed.</p></dd></dl><dl><dt>raises Assignment_to_non_var</dt><dd><p>if <code>e1</code>'s evaluation isn't a variable/identifier.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-cadd"><a href="#val-cadd" class="anchor"></a><code><span class="keyword">val</span> cadd : <span>e1:<a href="../Serial_interp/Ast/index.html#type-int_expr">Serial_interp.Ast.int_expr</a></span> <span>&#45;&gt;</span> <span>e2:<a href="../Serial_interp/Ast/index.html#type-int_expr">Serial_interp.Ast.int_expr</a></span> <span>&#45;&gt;</span> <span>state:<a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a></span> <span>&#45;&gt;</span> <a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a></code></dt><dd><p>Performs constructive sum:</p><ol><li>Evaluates <code>e1</code>, making sure it's a variable;</li><li>Evaluates <code>e2</code>;</li><li>Sums <code>e2</code>'s evaluation to the variable specified by <code>e1</code>, and returns the state with the above changes applied (see <span class="xref-unresolved" title="unresolved reference to &quot;State.cadd&quot;"><code>State</code>.cadd</span> for details.)</li></ol><dl><dt>parameter e1</dt><dd><p>The expression containing the variable to which we must add <code>e2</code>'s evaluation</p></dd></dl><dl><dt>parameter e2</dt><dd><p>The expression containing the value to add to the variable specified by <code>e1</code>.</p></dd></dl><dl><dt>parameter state</dt><dd><p>The state where the sum must be performed.</p></dd></dl><dl><dt>returns</dt><dd><p>The new state where the sum has been performed.</p></dd></dl><dl><dt>raises Assignment_to_non_var</dt><dd><p>if <code>e1</code>'s evaluation isn't a variable/identifier.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-csub"><a href="#val-csub" class="anchor"></a><code><span class="keyword">val</span> csub : <span>e1:<a href="../Serial_interp/Ast/index.html#type-int_expr">Serial_interp.Ast.int_expr</a></span> <span>&#45;&gt;</span> <span>e2:<a href="../Serial_interp/Ast/index.html#type-int_expr">Serial_interp.Ast.int_expr</a></span> <span>&#45;&gt;</span> <span>state:<a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a></span> <span>&#45;&gt;</span> <a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a></code></dt><dd><p>Performs constructive subtraction:</p><ol><li>Evaluates <code>e1</code>, making sure it's a variable;</li><li>Evaluates <code>e2</code>;</li><li>Subtracts <code>e2</code>'s evaluation from the variable specified by <code>e1</code>, and returns the state with the above changes applied (see <span class="xref-unresolved" title="unresolved reference to &quot;State.csub&quot;"><code>State</code>.csub</span> for details.)</li></ol><dl><dt>parameter e1</dt><dd><p>The expression containing the variable from which we must subtract <code>e2</code>'s evaluation</p></dd></dl><dl><dt>parameter e2</dt><dd><p>The expression containing the value to subtract from the variable specified by <code>e1</code>.</p></dd></dl><dl><dt>parameter state</dt><dd><p>The state where the subtraction must be performed.</p></dd></dl><dl><dt>returns</dt><dd><p>The new state where the subtraction has been performed.</p></dd></dl><dl><dt>raises Assignment_to_non_var</dt><dd><p>if <code>e1</code>'s evaluation isn't a variable/identifier.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-if_eval_fwd"><a href="#val-if_eval_fwd" class="anchor"></a><code><span class="keyword">val</span> if_eval_fwd : <span>b:<a href="../Serial_interp/Ast/index.html#type-bool_expr">Serial_interp.Ast.bool_expr</a></span> <span>&#45;&gt;</span> <span>prg1:<a href="../Serial_interp/Ast_aug/index.html#type-program_aug">Serial_interp.Ast_aug.program_aug</a></span> <span>&#45;&gt;</span> <span>prg2:<a href="../Serial_interp/Ast_aug/index.html#type-program_aug">Serial_interp.Ast_aug.program_aug</a></span> <span>&#45;&gt;</span> <span>state:<a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a></span> <span>&#45;&gt;</span> <a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a></code></dt><dd><p>Evaluates <code>Ifthenelse</code> statements during forward execution.</p><p>The following operations are performed in the given order:</p><ol><li><code>b</code> (<code>Ifthenelse</code>'s boolean expression) is evaluated;</li><li><code>prg</code> (The current program where the <code>Ifthenelse</code> statement was encountered) is retrieved from <code>state</code>;</li><li>If the result of <code>b</code>'s evaluation is <code>true</code>, <code>prg1</code> (the program associated with the &quot;then&quot; branch) is assigned to <code>if_prg_block</code> for further processing; otherwise (<code>b</code>'s evaluation is <code>false</code>), <code>prg2</code> (the program associated with the &quot;else&quot; branch) is assigned to <code>if_prg_block</code> for further processing;</li><li><code>Ifthenelse</code>'s branch to be executed (<code>if_prg_block</code>) gets augmented by calling <span class="xref-unresolved" title="unresolved reference to &quot;Augment.aug_if_block&quot;"><code>Augment</code>.aug_if_block</span> and the augmented program is assigned to <code>aug_if_prg_block</code>;</li><li>A new state containing <code>aug_if_prg_block</code> as program is returned.</li></ol><dl><dt>parameter b</dt><dd><p><code>Ifthenelse</code>'s boolean expression, whose evaluation determines whether to execute <code>prg1</code> or <code>prg2</code>.</p></dd></dl><dl><dt>parameter prg1</dt><dd><p>The program associated with <code>Ifthenelse</code>'s &quot;then&quot; branch.</p></dd></dl><dl><dt>parameter prg2</dt><dd><p>The program associated with <code>Ifthenelse</code>'s &quot;else&quot; branch.</p></dd></dl><dl><dt>parameter state</dt><dd><p>The state where the <code>Ifthenelse</code> statement under analysis was encountered.</p></dd></dl><dl><dt>returns</dt><dd><p>A new state having as program the augmented <code>Ifthenelse</code> branch to execute.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-if_eval_rev"><a href="#val-if_eval_rev" class="anchor"></a><code><span class="keyword">val</span> if_eval_rev : <span>prg1:<a href="../Serial_interp/Ast_aug/index.html#type-program_aug">Serial_interp.Ast_aug.program_aug</a></span> <span>&#45;&gt;</span> <span>prg2:<a href="../Serial_interp/Ast_aug/index.html#type-program_aug">Serial_interp.Ast_aug.program_aug</a></span> <span>&#45;&gt;</span> <span>state:<a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a></span> <span>&#45;&gt;</span> <a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a></code></dt><dd><p>Evaluates <code>Ifthenelse</code> statements during reverse execution.</p><p>The following operations are performed in the given order:</p><ol><li><code>b_eval</code> (<code>Ifthenelse</code>'s boolean evaluation, which was evaluated during forward execution) is retrieved and removed(popped) from <span class="xref-unresolved" title="unresolved reference to &quot;Delta.if_stack&quot;"><code>Delta</code>.if_stack</span> in the auxiliary delta store;</li><li><code>new_state</code> is created by putting the new delta store with <code>b_eval</code> removed from the top of <span class="xref-unresolved" title="unresolved reference to &quot;Delta.if_stack&quot;"><code>Delta</code>.if_stack</span>, and moving the program's current statement one statement backward (keep in mind that <a href="index.html#val-sem_stmt_rev"><code>sem_stmt_rev</code></a> evaluates the <b>previous</b> statement rather than the current one, therefore if we want <code>Ifthenelse</code> to become the current statement we must move one step back);</li><li><code>prg</code> (The current program where the <code>Ifthenelse</code> statement under evaluation is now the current statement) is retrieved from <code>new_state</code>;</li><li>If the result of <code>b_eval</code> is <code>true</code>, <code>prg1</code> (the program associated with the &quot;then&quot; branch) is assigned to <code>if_prg_block</code> for further processing; otherwise (<code>b</code>'s evaluation is <code>false</code>), <code>prg2</code> (the program associated with the &quot;else&quot; branch) is assigned to <code>if_prg_block</code> for further processing;</li><li><code>Ifthenelse</code>'s branch to be executed (<code>if_prg_block</code>) gets augmented by calling <span class="xref-unresolved" title="unresolved reference to &quot;Augment.aug_if_block&quot;"><code>Augment</code>.aug_if_block</span>; the current statement in the augmented program is set to the last one by feeding it to <span class="xref-unresolved" title="unresolved reference to &quot;Program.last_stmt&quot;"><code>Program</code>.last_stmt</span> (we are performing reverse execution, so we must begin from the program's last statement) and the result is assigned to <code>aug_if_prg_block</code>;</li><li>A new state containing <code>aug_if_prg_block</code> as program is returned.</li></ol><dl><dt>parameter prg1</dt><dd><p>The program associated with <code>Ifthenelse</code>'s &quot;then&quot; branch.</p></dd></dl><dl><dt>parameter prg2</dt><dd><p>The program associated with <code>Ifthenelse</code>'s &quot;else&quot; branch.</p></dd></dl><dl><dt>parameter state</dt><dd><p>The state where the <code>Ifthenelse</code> statement under analysis was encountered.</p></dd></dl><dl><dt>returns</dt><dd><p>A new state having as program the augmented <code>Ifthenelse</code> branch to execute (starting from the program's last statement), as well as an updated <span class="xref-unresolved" title="unresolved reference to &quot;Delta.if_stack&quot;"><code>Delta</code>.if_stack</span> in the sigma store with the top value removed from the stack.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-while_eval_fwd"><a href="#val-while_eval_fwd" class="anchor"></a><code><span class="keyword">val</span> while_eval_fwd : <span>b_expr:<a href="../Serial_interp/Ast/index.html#type-bool_expr">Serial_interp.Ast.bool_expr</a></span> <span>&#45;&gt;</span> <span>while_prg:<a href="../Serial_interp/Ast_aug/index.html#type-program_aug">Serial_interp.Ast_aug.program_aug</a></span> <span>&#45;&gt;</span> <span>state:<a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a></span> <span>&#45;&gt;</span> <a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a></code></dt><dd><p>Evaluates <code>While</code> statements during forward execution.</p><p>The following operations are performed in the given order:</p><ol><li><code>b_expr</code> (<code>While</code>'s boolean expression) is evaluated and assigned to <code>b_eval</code>;</li><li><code>new_state</code> is created by pushing <code>false</code> onto <span class="xref-unresolved" title="unresolved reference to &quot;Delta.while_stack&quot;"><code>Delta</code>.while_stack</span>; this step is necessary since during forward execution we have the following two scenarios:</li></ol><ul><li><code>While</code>'s first <code>b_expr</code> evaluation was <code>false</code> (<code>While</code>'s program block was skipped): since no <code>true</code> values were pushed onto <span class="xref-unresolved" title="unresolved reference to &quot;Delta.while_stack&quot;"><code>Delta</code>.while_stack</span>, the <code>false</code> value we pushed gets popped during reverse execution and <code>While</code>'s program block gets skipped again;</li><li><code>While</code>'s <code>b_expr</code> evaluates to <code>true</code> for a given <b>n</b> amount of times; <b>n</b> <code>true</code> values get pushed onto <span class="xref-unresolved" title="unresolved reference to &quot;Delta.while_stack&quot;"><code>Delta</code>.while_stack</span>, therefore during reverse execution we pop those <code>true</code> values which make the interpreter iterate <code>While</code>'s program block <b>n</b> times, at which point the <code>false</code> value we pushed gets popped and <code>While</code>'s reverse iteration stops.</li></ul><ol><li>The program having the statement following the current <code>While</code> as the current statement is assigned to <code>prg_while_next_stmt</code>;</li><li>if <code>b_eval</code> is <code>true</code>, it means we must execute the program block inside <code>While</code> at least once, therefore <code>while_prg</code> gets augmented by calling <span class="xref-unresolved" title="unresolved reference to &quot;Augment.aug_while_block&quot;"><code>Augment</code>.aug_while_block</span> and assigned to <code>prg_to_execute</code>; otherwise (<code>b_eval</code> = <code>false</code>), <code>While</code>'s program block gets skipped and <code>prg_while_next_stmt</code> is assigned to <code>prg_to_execute</code>;</li><li>A state having <code>prg_to_execute</code> as program and <code>new_state</code> as state is returned.</li></ol><dl><dt>parameter b_expr</dt><dd><p><code>While</code>'s boolean expression.</p></dd></dl><dl><dt>parameter while_prg</dt><dd><p>The program associated to <code>While</code>'s body;</p></dd></dl><dl><dt>parameter state</dt><dd><p>The state where the <code>While</code> statement has been encountered.</p></dd></dl><dl><dt>returns</dt><dd><p>A state having:</p><ul><li>as a program: the augmented <code>while_prg</code> if <code>b_expr</code>'s evaluation is <code>true</code>, or the program having the statement following the <code>While</code> under evaluation as current statement if <code>b_expr</code>'s evaluation is <code>false</code>;</li><li>as sigma store: the same as the <code>state</code> parameter;</li><li>as auxiliary delta store: <code>state</code>'s delta store, with <code>false</code> pushed onto <span class="xref-unresolved" title="unresolved reference to &quot;Delta.while_stack&quot;"><code>Delta</code>.while_stack</span>.</li></ul></dd></dl></dd></dl><dl><dt class="spec value" id="val-while_eval_rev"><a href="#val-while_eval_rev" class="anchor"></a><code><span class="keyword">val</span> while_eval_rev : <span>b_expr:<a href="../Serial_interp/Ast/index.html#type-bool_expr">Serial_interp.Ast.bool_expr</a></span> <span>&#45;&gt;</span> <span>while_prg:<a href="../Serial_interp/Ast_aug/index.html#type-program_aug">Serial_interp.Ast_aug.program_aug</a></span> <span>&#45;&gt;</span> <span>state:<a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a></span> <span>&#45;&gt;</span> <a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a></code></dt><dd><p>Evaluates <code>While</code> statements during reverse execution.</p><p>The following operations are performed in the given order:</p><ol><li>The boolean value on the top of <span class="xref-unresolved" title="unresolved reference to &quot;Delta.while_stack&quot;"><code>Delta</code>.while_stack</span> gets retrieved and assigned to <code>b_eval</code>;</li><li><code>new_state</code> is created from <code>state</code> by removing (popping) <span class="xref-unresolved" title="unresolved reference to &quot;Delta.while_stack&quot;"><code>Delta</code>.while_stack</span>'s top value and setting as the current statement the <code>While</code> statement (keep in mind that <a href="index.html#val-sem_stmt_rev"><code>sem_stmt_rev</code></a> evaluates the <b>previous</b> statement rather than the current one, therefore if we want <code>While</code> to become the current statement we must move one step back);</li><li>The program having the statement preceding the current <code>While</code> as the current statement is assigned to <code>prg_while_prev_stmt</code>;</li><li>if <code>b_eval</code> is <code>true</code>, it means we must execute the program block inside <code>While</code> at least once, therefore <code>while_prg</code> gets augmented by calling <span class="xref-unresolved" title="unresolved reference to &quot;Augment.aug_while_block&quot;"><code>Augment</code>.aug_while_block</span> and assigned to <code>prg_to_execute</code>; otherwise (<code>b_eval</code> = <code>false</code>), <code>While</code>'s program block gets skipped and <code>prg_while_next_stmt</code> is assigned to <code>prg_to_execute</code>;</li><li>A state having <code>prg_to_execute</code> as program and <code>new_state</code> as state is returned.</li></ol><dl><dt>parameter b_expr</dt><dd><p><code>While</code>'s boolean expression.</p></dd></dl><dl><dt>parameter while_prg</dt><dd><p>The program associated to <code>While</code>'s body;</p></dd></dl><dl><dt>parameter state</dt><dd><p>The state where the <code>While</code> statement has been encountered.</p></dd></dl><dl><dt>returns</dt><dd><p>A state having:</p><ul><li>as a program: the augmented <code>while_prg</code> if <code>b_expr</code>'s evaluation is <code>true</code>, or the program having the statement following the <code>While</code> under evaluation as current statement if <code>b_expr</code>'s evaluation is <code>false</code>;</li><li>as sigma store: the same as the <code>state</code> parameter;</li><li>as auxiliary delta store: <code>state</code>'s delta store, with <code>false</code> pushed onto <span class="xref-unresolved" title="unresolved reference to &quot;Delta.while_stack&quot;"><code>Delta</code>.while_stack</span>.</li></ul></dd></dl></dd></dl><dl><dt class="spec value" id="val-while_start_eval"><a href="#val-while_start_eval" class="anchor"></a><code><span class="keyword">val</span> while_start_eval : <span>while_stmt_in_outer_prg:<a href="../Serial_interp/Ast_aug/index.html#type-program_aug">Serial_interp.Ast_aug.program_aug</a></span> <span>&#45;&gt;</span> <span>state:<a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a></span> <span>&#45;&gt;</span> <a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a></code></dt><dd><p>Evaluates <code>While_start</code> statements during reverse execution.</p><p>NOTE: <code>While_start</code> statements can be evaluated ONLY during reverse execution, since they mark the beginning of a <code>While</code>'s program body; if they get evaluated during forward execution, then there's a problem (exception <code>Illegal_statement_fwd_execution</code> would be raised), but it should never happen anyway.</p><p>The following operations are performed in the given order:</p><ol><li>The boolean value on the top of <span class="xref-unresolved" title="unresolved reference to &quot;Delta.while_stack&quot;"><code>Delta</code>.while_stack</span> gets retrieved and assigned to <code>b_eval</code>;</li><li><code>new_state</code> is created from <code>state</code> by removing (popping) <span class="xref-unresolved" title="unresolved reference to &quot;Delta.while_stack&quot;"><code>Delta</code>.while_stack</span>'s top value (which we just assigned to <code>b_eval</code> in the previous step);</li><li>if <code>b_eval</code> is <code>true</code>, it means we must perform another reverse iteration of the <code>While</code> program block we're currently executing starting from the last statement,therefore we set the current statement to the last statement of the current program block (by calling <span class="xref-unresolved" title="unresolved reference to &quot;Program.last_stmt&quot;"><code>Program</code>.last_stmt</span>) and the result is assigned to <code>prg_to_execute</code>. Otherwise (<code>b_eval</code> is <code>false</code>), it means the last iteration of <code>While</code>'s program has been performed and we need to jump out of the loop, therefore <code>while_stmt_in_outer_prg</code> (which is <code>While_start</code>'s parameter consisting in the outer program having as current statement the <code>While</code> statement containing the program block which is currently being executed) gets assigned to <code>prg_to_execute</code>;</li><li>A state having <code>prg_to_execute</code> as program and <code>new_state</code> as state is returned.</li></ol><dl><dt>parameter while_stmt_in_outer_prg</dt><dd><p>The program having the <code>While</code> statement whose body is being executed, where execution will continue in case reverse iteration must be stopped due to a <code>false</code> value popped from <span class="xref-unresolved" title="unresolved reference to &quot;Delta.while_stack&quot;"><code>Delta</code>.while_stack</span>.</p></dd></dl><dl><dt>parameter state</dt><dd><p>The current state, where the <code>While_start</code> statement has been encountered.</p></dd></dl><dl><dt>returns</dt><dd><p>A state having:</p><ul><li>as a program: the current program having the current statement set to the program's last statement if the value retrieved from <span class="xref-unresolved" title="unresolved reference to &quot;Delta.while_stack&quot;"><code>Delta</code>.while_stack</span> is <code>true</code>, or <code>while_stmt_in_outer_prg</code> if the value retrieved from <span class="xref-unresolved" title="unresolved reference to &quot;Delta.while_stack&quot;"><code>Delta</code>.while_stack</span> is <code>false</code>;</li><li>as sigma store: the same as the <code>state</code> parameter;</li><li>as auxiliary delta store: <code>state</code>'s delta store, with the retrieved boolean value <code>b_eval</code> popped(removed) from the top of <span class="xref-unresolved" title="unresolved reference to &quot;Delta.while_stack&quot;"><code>Delta</code>.while_stack</span>.</li></ul></dd></dl></dd></dl><dl><dt class="spec value" id="val-while_end_eval"><a href="#val-while_end_eval" class="anchor"></a><code><span class="keyword">val</span> while_end_eval : <span>b_expr:<a href="../Serial_interp/Ast/index.html#type-bool_expr">Serial_interp.Ast.bool_expr</a></span> <span>&#45;&gt;</span> <span>while_next_stmt_in_outer_prg:<a href="../Serial_interp/Ast_aug/index.html#type-program_aug">Serial_interp.Ast_aug.program_aug</a></span> <span>&#45;&gt;</span> <span>state:<a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a></span> <span>&#45;&gt;</span> <a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a></code></dt><dd><p>Evaluates <code>While_end</code> statements during forward execution.</p><p>NOTE: <code>While_end</code> statements can be evaluated ONLY during forward execution, since they mark the end of a <code>While</code>'s program body; if they get evaluated during reverse execution, then there's a problem (exception <code>Illegal_statement_rev_execution</code> would be raised), but it should never happen anyway.</p><p>The following operations are performed in the given order:</p><ol><li><code>b_expr</code> (<code>While</code>'s boolean expression) is evaluated and assigned to <code>b_eval</code>;</li><li><code>new_state</code> is created from <code>state</code> by pushing <code>true</code> onto <span class="xref-unresolved" title="unresolved reference to &quot;Delta.while_stack&quot;"><code>Delta</code>.while_stack</span> (We're at the end of a <code>While</code> program iteration which has has been executed, therefore we must push <code>true</code> to mark the fact an iteration has been executed when we reverse execute the program, regardless of <code>b_eval</code>'s value);</li><li>if <code>b_eval</code> is <code>true</code>, it means we must perform another forward iteration of the <code>While</code> program block we're currently executing starting from the first statement,therefore we set the current statement to the first statement of the current program block (by calling <span class="xref-unresolved" title="unresolved reference to &quot;Program.while_block_1st_stmt&quot;"><code>Program</code>.while_block_1st_stmt</span>) and the result is assigned to <code>prg_to_execute</code>. Otherwise (<code>b_eval</code> is <code>false</code>), it means the last iteration of <code>While</code>'s program has been performed and we need to jump out of the loop, therefore <code>while_next_stmt_in_outer_prg</code> (which is <code>While_end</code>'s parameter consisting in the outer program having as current statement the statement following the <code>While</code> statement containing the program block which is currently being executed) is assigned to <code>prg_to_execute</code>;</li><li>A state having <code>prg_to_execute</code> as program and <code>new_state</code> as state is returned.</li></ol><dl><dt>parameter b_expr</dt><dd><p><code>While_end</code>'s boolean expression, inherited from the containing <code>While</code> statement.</p></dd></dl><dl><dt>parameter while_next_stmt_in_outer_prg</dt><dd><p>The program having the <code>While</code> statement whose body is being executed, where execution will continue to <code>While</code>'s next statement in case iteration must be stopped due to <code>b_expr</code> evaluating to <code>false</code>.</p></dd></dl><dl><dt>parameter state</dt><dd><p>The current state, where the <code>While_start</code> statement has been encountered.</p></dd></dl><dl><dt>returns</dt><dd><p>A state having:</p><ul><li>as a program: the current program having the current statement set to the program's first statement if <code>b_expr</code>'s evaluation is <code>true</code>, or <code>while_next_stmt_in_outer_prg</code> if <code>b_expr</code>'s evaluation is <code>false</code>;</li><li>as sigma store: the same as the <code>state</code> parameter;</li><li>as auxiliary delta store: <code>state</code>'s delta store, with <code>true</code> pushed onto <span class="xref-unresolved" title="unresolved reference to &quot;Delta.while_stack&quot;"><code>Delta</code>.while_stack</span>.</li></ul></dd></dl></dd></dl><dl><dt class="spec value" id="val-sem_stmt_fwd"><a href="#val-sem_stmt_fwd" class="anchor"></a><code><span class="keyword">val</span> sem_stmt_fwd : <a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a> <span>&#45;&gt;</span> <a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a></code></dt><dd><p>Given a state, performs a single evaluation step in forward execution mode and returns the resulting state.</p></dd></dl><dl><dt class="spec value" id="val-sem_stmt_rev"><a href="#val-sem_stmt_rev" class="anchor"></a><code><span class="keyword">val</span> sem_stmt_rev : <a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a> <span>&#45;&gt;</span> <a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a></code></dt><dd><p>Given a state, performs a single evaluation step in reverse execution mode and returns the resulting state.</p></dd></dl><dl><dt class="spec value" id="val-sem_prg_fwd"><a href="#val-sem_prg_fwd" class="anchor"></a><code><span class="keyword">val</span> sem_prg_fwd : <a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a> <span>&#45;&gt;</span> <a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a></code></dt><dd><p>Given a state, evaluates all statements until the end of the program in forward execution mode and returns the resulting state.</p></dd></dl><dl><dt class="spec value" id="val-sem_prg_rev"><a href="#val-sem_prg_rev" class="anchor"></a><code><span class="keyword">val</span> sem_prg_rev : <a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a> <span>&#45;&gt;</span> <a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a></code></dt><dd><p>Given a state, evaluates all statements until the beginning of the program in reverse execution mode and returns the resulting state.</p></dd></dl><dl><dt class="spec value" id="val-sem_prg_fwd_steps"><a href="#val-sem_prg_fwd_steps" class="anchor"></a><code><span class="keyword">val</span> sem_prg_fwd_steps : <a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a></code></dt><dd><p>Given a state <code>curr_state</code> and a specified <code>num_steps</code> integer, let <code>remaining_stmts</code> be the number of statements between the current statement in <code>curr_state</code>'s program and the <code>Program_end</code> boundary statement; then the function performs min(<code>remaining_stmts</code>, <code>num_steps</code>) statement evaluations in forward execution mode and returns the resulting state.</p><p>If <code>num_steps</code> &lt;= 0, <code>curr_state</code> is returned unaltered.</p></dd></dl><dl><dt class="spec value" id="val-sem_prg_rev_steps"><a href="#val-sem_prg_rev_steps" class="anchor"></a><code><span class="keyword">val</span> sem_prg_rev_steps : <a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a></code></dt><dd><p>Given a state <code>curr_state</code> and a specified <code>num_steps</code> integer, let <code>remaining_stmts</code> be the number of statements between the current statement in <code>curr_state</code>'s program and the <code>Program_start</code> boundary statement; then the function performs min(<code>remaining_stmts</code>, <code>num_steps</code>) statement evaluations in reverse execution mode and returns the resulting state.</p><p>If <code>num_steps</code> &lt;= 0, <code>curr_state</code> is returned unaltered.</p></dd></dl><dl><dt class="spec value" id="val-sem_prg_steps"><a href="#val-sem_prg_steps" class="anchor"></a><code><span class="keyword">val</span> sem_prg_steps : <a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="../Serial_interp/State/index.html#type-state">Serial_interp.State.state</a></code></dt><dd><p>Given a state <code>curr_state</code> and a specified <code>num_steps</code> integer, it acts as an interface allowing both forward and reverse execution by calling</p><ul><li><a href="index.html#val-sem_prg_fwd_steps"><code>sem_prg_fwd_steps</code></a> (forward execution), if <code>num_steps</code> &gt;= 0;</li><li><a href="index.html#val-sem_prg_rev_steps"><code>sem_prg_rev_steps</code></a> (reverse execution), if <code>num_steps</code> &lt; 0 (in this case, <code>num_steps</code>'s sign gets inverted to obtain the positive amount of steps to execute to pass to <a href="index.html#val-sem_prg_rev_steps"><code>sem_prg_rev_steps</code></a> as parameter.)</li></ul></dd></dl></div></body></html>