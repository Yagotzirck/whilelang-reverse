<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ast_aug (serial_interp@26bb1931b3ad.Serial_interp.Ast_aug)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">serial_interp@26bb1931b3ad</a> &#x00BB; <a href="../index.html">Serial_interp</a> &#x00BB; Ast_aug</nav><h1>Module <code>Serial_interp.Ast_aug</code></h1></header><aside><p>Abstract syntax tree for the augmented serial version of the while language.</p></aside><dl><dt class="spec type" id="type-program_aug"><a href="#type-program_aug" class="anchor"></a><code><span class="keyword">type</span> program_aug</code><code> = </code><table class="variant"><tr id="type-program_aug.Program_aug" class="anchored"><td class="def constructor"><a href="#type-program_aug.Program_aug" class="anchor"></a><code>| </code><code><span class="constructor">Program_aug</span> <span class="keyword">of</span> <span><a href="index.html#type-stmt_aug">stmt_aug</a> list</span> * <a href="index.html#type-stmt_aug">stmt_aug</a> * <span><a href="index.html#type-stmt_aug">stmt_aug</a> list</span></code></td></tr></table></dt><dd><p>In the augmented version we must allow forwards as well as backwards execution, therefore we must implement a doubly-linked list (or rather, its functional equivalent: a zipper) in order to allow movement in both directions.</p><p>In order to explain how a zipper works, let's start from this simple integer list:</p><p><code>[1; 2; 3; 4; 5; 6]</code></p><p>Its zipper representation would consist in a tuple containing:</p><ul><li>A list containing the items to the left of the current element (<code>prev_items</code>);</li><li>The current item (<code>curr_item</code>);</li><li>A list containing the elements to the right of the current element (<code>next_items</code>).</li></ul><p>Therefore, the previous list converted to a zipper would be:</p><p><code>( [], 1, [2; 3; 4; 5; 6] )</code></p><p>A <code>next_item</code> operation</p><ul><li>moves <code>curr_item</code> to the head of <code>prev_items</code> list;</li><li>moves the head of <code>next_items</code> to <code>curr_item</code>.</li></ul><p>Applying <code>next_item</code> to the previous zipper yields</p><p><code>( 1 :: [], 2, [3; 4; 5; 6] )</code></p><p>If we apply <code>next_item</code> two more times, we get</p><p><code>( [3; 2; 1]), 4, [5; 6] )</code></p><p>A <code>prev_item</code> operation</p><ul><li>moves <code>curr_item</code> to the head of <code>next_items</code> list;</li><li>moves the head of <code>prev_items</code> to <code>curr_item</code>.</li></ul><p>Applying <code>prev_item</code> to the last zipper we obtained above yields</p><p><code>( [2; 1]), 3, [4; 5; 6] )</code></p><p>It should be clear at this point that the zipper is the ideal structure that achieves a doubly linked list-like behavior using the functional programming paradigm, allowing us to move in both directions starting from a given list of items (in our case, a list of statements/instructions).</p></dd></dl><dl><dt class="spec type" id="type-stmt_aug"><a href="#type-stmt_aug" class="anchor"></a><code><span class="keyword">and</span> stmt_aug</code><code> = </code><table class="variant"><tr id="type-stmt_aug.Program_start" class="anchored"><td class="def constructor"><a href="#type-stmt_aug.Program_start" class="anchor"></a><code>| </code><code><span class="constructor">Program_start</span></code></td></tr><tr id="type-stmt_aug.Program_end" class="anchored"><td class="def constructor"><a href="#type-stmt_aug.Program_end" class="anchor"></a><code>| </code><code><span class="constructor">Program_end</span></code></td></tr><tr id="type-stmt_aug.Skip" class="anchored"><td class="def constructor"><a href="#type-stmt_aug.Skip" class="anchor"></a><code>| </code><code><span class="constructor">Skip</span></code></td></tr><tr id="type-stmt_aug.Assign" class="anchored"><td class="def constructor"><a href="#type-stmt_aug.Assign" class="anchor"></a><code>| </code><code><span class="constructor">Assign</span> <span class="keyword">of</span> <a href="../Ast/index.html#type-int_expr">Ast.int_expr</a> * <a href="../Ast/index.html#type-int_expr">Ast.int_expr</a></code></td><td class="doc"><p>Destructive assignment; 1st <code>int_expr</code> must be <a href="../Ast/index.html#type-int_expr.Val"><code>Ast.int_expr.Val</code></a></p></td></tr><tr id="type-stmt_aug.Cadd" class="anchored"><td class="def constructor"><a href="#type-stmt_aug.Cadd" class="anchor"></a><code>| </code><code><span class="constructor">Cadd</span> <span class="keyword">of</span> <a href="../Ast/index.html#type-int_expr">Ast.int_expr</a> * <a href="../Ast/index.html#type-int_expr">Ast.int_expr</a></code></td><td class="doc"><p>Constructive assignment (&quot;+=&quot;); must check about 1st <code>int_expr</code> being <a href="../Ast/index.html#type-int_expr.Val"><code>Ast.int_expr.Val</code></a></p></td></tr><tr id="type-stmt_aug.Csub" class="anchored"><td class="def constructor"><a href="#type-stmt_aug.Csub" class="anchor"></a><code>| </code><code><span class="constructor">Csub</span> <span class="keyword">of</span> <a href="../Ast/index.html#type-int_expr">Ast.int_expr</a> * <a href="../Ast/index.html#type-int_expr">Ast.int_expr</a></code></td><td class="doc"><p>Constructive assignment (&quot;-=&quot;); must check about 1st <code>int_expr</code> being <a href="../Ast/index.html#type-int_expr.Val"><code>Ast.int_expr.Val</code></a></p></td></tr><tr id="type-stmt_aug.Ifthenelse" class="anchored"><td class="def constructor"><a href="#type-stmt_aug.Ifthenelse" class="anchor"></a><code>| </code><code><span class="constructor">Ifthenelse</span> <span class="keyword">of</span> <a href="../Ast/index.html#type-bool_expr">Ast.bool_expr</a> * <a href="index.html#type-program_aug">program_aug</a> * <a href="index.html#type-program_aug">program_aug</a></code></td></tr><tr id="type-stmt_aug.If_start" class="anchored"><td class="def constructor"><a href="#type-stmt_aug.If_start" class="anchor"></a><code>| </code><code><span class="constructor">If_start</span> <span class="keyword">of</span> <a href="index.html#type-program_aug">program_aug</a></code></td><td class="doc"><p>Parameter: <code>prg_prev</code>; that is, the program having the outer <code>If</code> containing this program block as the current statement</p></td></tr><tr id="type-stmt_aug.If_end" class="anchored"><td class="def constructor"><a href="#type-stmt_aug.If_end" class="anchor"></a><code>| </code><code><span class="constructor">If_end</span> <span class="keyword">of</span> <a href="index.html#type-program_aug">program_aug</a> * bool</code></td></tr><tr id="type-stmt_aug.While" class="anchored"><td class="def constructor"><a href="#type-stmt_aug.While" class="anchor"></a><code>| </code><code><span class="constructor">While</span> <span class="keyword">of</span> <a href="../Ast/index.html#type-bool_expr">Ast.bool_expr</a> * <a href="index.html#type-program_aug">program_aug</a></code></td><td class="doc"><p>Parameters: <code>(prg_next, if_b_eval)</code></p></td></tr><tr id="type-stmt_aug.While_start" class="anchored"><td class="def constructor"><a href="#type-stmt_aug.While_start" class="anchor"></a><code>| </code><code><span class="constructor">While_start</span> <span class="keyword">of</span> <a href="index.html#type-program_aug">program_aug</a></code></td><td class="doc"><p>Parameter: <code>while_in_outer_prg</code></p></td></tr><tr id="type-stmt_aug.While_end" class="anchored"><td class="def constructor"><a href="#type-stmt_aug.While_end" class="anchor"></a><code>| </code><code><span class="constructor">While_end</span> <span class="keyword">of</span> <a href="../Ast/index.html#type-bool_expr">Ast.bool_expr</a> * <a href="index.html#type-program_aug">program_aug</a></code></td><td class="doc"><p>Parameters: <code>(bool_expr, while_in_outer_prg)</code></p></td></tr></table></dt><dd><p>Statements must be augmented as well with the following additions:</p><ul><li><code>Program_start</code> and <code>Program_end</code>, in order to set boundaries for the whole program;</li><li><code>If_start</code> and <code>If_end</code>, in order to set boundaries for programs inside the &quot;then&quot; and &quot;else&quot; branches;</li><li><code>While_start</code> and <code>While_end</code>, in order to set boundaries for programs constituting While blocks.</li></ul></dd></dl></div></body></html>